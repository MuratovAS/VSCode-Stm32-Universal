# История о том, как собрать вкусную среду для ARM

В один прекрасный день появилась необходимость в гибкой и функциональной среде разработки, под stm32. Взор упал на молодой продукт от ST под названием **STM32CubeIDE**, она хороша, основное преимущество это работа из коробки с достаточно широкими функциональными возможностями. К большому сожалению она базируется на **Eclipse**, хотя многие назовут это плюсом. Недостатки: очень прожорливая, медленная, интуитивно не понятная, устаревший дизайн. О преимуществах рассказывать не буду, раз вы это читаете  значит вы уже все сами знаете :)
Мой взор упал на VSCode, по сравнению с конкурентами он быстрый, хорошая поддержка, ну и конечно же бесплатный. не будем тянуть и приступим к делу. 
Стоит отметить, все проверялось на Kubuntu 19.10 и китайском ST-Link и Bluepill

## Начнем с C/C++

Жизненно необходимые пакеты, без них будет сложно жить. необходимы для сборки и менеджмента проектом.

~~~bash
sudo apt install git
sudo apt install make
sudo apt install mс
~~~

### Первый шаг ToolChain

Качаем с официального сайта, в репозитории (Ubuntu) очень обрезанная версия, не годится она под наши нужды.


https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads


Распаковать в каталог /opt/gcc-arm/ с помощью Midnight Commander (mc), не забываем про root права 


Для удобства использования, пропишем в PATH, это позволит запускать приложения без полного пути
~~~bash
nano /home/user/.bashrc
~~~
Добавляем в конец файла такую строку
~~~bash
export PATH=/opt/gcc-arm/bin:$PATH
~~~

Проверим работоспособность компилятора, если все **ок**, продолжаем дальше

~~~bash
arm-none-eabi-gcc --version
~~~

Проверяем работоспособность пакета отладки

~~~bash
arm-none-eabi-gdb
~~~

в случае ошибки устанавливаем дополнительные библиотеки 

~~~bash
sudo apt-get install ia32-libs
sudo apt-get install libncurses5:amd64
~~~

### Установим систему отладки 

~~~bash
sudo apt-get install openocd
~~~

Проверим корректность установки, проблем обычно не возникает с этим пакетом. 

~~~bash
openocd --version
~~~

### Установим пакеты для работы с STLINK

~~~bash
sudo apt install stlink-tools
~~~

Не ленимся проверить работоспособность, в последствии сложно будет найти не функционирующий узел нашей системы. 

~~~bash
st-info
~~~

Если пакет установлен, можно подключить какой нибудь контроллер через ST-Link и попытаться получить информацию 

~~~bas
st-info --probe
~~~

Мало ли пригодится, с помощью этой команды можно сразу прошить контроллер Bin файлом 

~~~bash
st-flash write ./miniblink.bin 0x8000000
~~~

### Приближаемся непосредственно к среде разработки 

Качаем STM32cubeMX, он нам необходим что бы с генерировать проект, да и в принципе без него сложно представить разработку, очень удобный инструмент


https://www.st.com/en/development-tools/stm32cubemx.html

Распаковываем и запускаем через терминал (не удивляйтесь, файл exe), должны увидеть процесс установки, следуем инструкциям. я устанавливаю в директорию /opt

~~~bash 
java -jar SetupSTM32CubeMX-4.11.0.exe
~~~

### Самое время создать проект 

Необходимо с генерировать проект для целевого микроконтроллера, с помощью STM32cubeMX. 
В настройка в качестве toolchain, указываем makefile.

Хороший человек **damogranlabs** написал script, который позволяет преобразовывать проект от stm32 в проект для VSCode, это очень упрощает дальнейшую работу. 

~~~bash
git clone https://github.com/damogranlabs/VS-Code-STM32-IDE
~~~

Не забывайте, перед выполнением данной команды, лучше быть уже в своей рабочей директории

### Установка и настройка IDE

Установим python3, он нам понадобится для завершения генерации проекта

~~~bash
sudo apt install python3
sudo apt install python3-pip
~~~

Настало время….. установить саму среду, а точнее IDE

~~~bash 
sudo apt install code
~~~


Для работы нам потребуется расширение Cortex-Debug, собственно это и есть “мост” между отладчиком и средой, ради которого столько стараний.

### Компиляция проекта

Открыть каталог проекта созданный CubeMX в VSCode
Сохраняем  WorkSpace (подпункт меню Файл) в корень каталога.

Осталось скопировать каталог **ideScripts** (из VS-Code-STM32-IDE) в корень нашего проекта. 

Для окончательной настройки проекта, запускаем script нашего товарища. Лучше это сделать прямо в IDE через встроенный терминал 

~~~bash
python3 ./ideScripts/update.py
~~~

Далее следуем инструкции. Необходимо вписать все пути которые он просит (подробнее это описано в README.md файле автора)
У меня не получилось использовать конфигурационные файлы идущие вместе с openocd, скрипт их просто не видел. Необходимые файлы я нашел на просторах интернета. Рекомендую поместить их сразу в  каталок .vscode нашего проекта, вам точно потребуются  stlink-v2.cfg, stm32f1xx.cfg, STM32F103xx.svd и уже указать относительный путь до них (пример ./.vscode/stlink-v2.cfg)

## Почему бы не попробовать Rust ?!

Уже было много разговоров о преимуществах этого языка. О безопасности этого языка и его быстродействие, на уровне cpp. Пока что он относительно молод, но в первом приближение можно сказать, у этого языка есть потенциал, это то что скорее всего заменить C/C++ в будущем.
Я немного постарался и написать Bash скрипт, позволяющий в два клика собирать проект для VSCode + Stm32 +Rust. Хотелось бы сразу сказать спасибо [smallnibbler](https://habr.com/ru/users/smallnibbler/) за хорошую статью. 

### Установим пакеты для компиляции новомодного языка

~~~ bash
sudo apt install curl
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
~~~

После предыдущего пункта, предается перезагрузился.  Настало время проверить работоспособность Rust.

~~~ bash
rustc --version
~~~

Устанавливаем полезное расширение, позволяющие преобразовывать elf в bin, подходящего к любому программатору.

~~~ bash
cargo install cargo-binutils
rustup component add llvm-tools-preview
~~~

не забываем в VS Code установить расширение Rust (rls)

### Создание проекта

Тут все горазд проще, чем с C/C++.

Клонируем репозиторий, в свою рабочую папку. 

~~~bash
git clone https://github.com/MuratovAS/VSCode-Stm32-Universal
~~~

В случае Stm32f103, имеется уже собранный проект, но куда интереснее собрать его самому SVD файл можно взять в .vscode/STM32F103xx.svd 
Каталог .vscode может быть скрытым в вашем файловым менеджером, включите “видимость скрытых файлов”.

Из репозитория нам понадобится файл **ProjectGenerator_Rust.sh**, это и есть генератор. Его и SVD необходимо переместить в каталог ваших экспериментов, в процессе он создаст новую папку для конкретного проекта. 

~~~bash
bash ProjectGenerator_Rust.sh
~~~

Выполняем и следуем инструкции, в скобках приведены примеры. Отличие от скрипта для C/C++ в том что пути к файлом можно прописывать относительные и использовать комплектные stlink-vX.cfg, stm32fXXX.cfg, кроме SVD файла его требуется положить в одну папку с *ProjectGenerator_Rust*. это очень **важно**.

## Немного о USB-COM

в Linux имеется проблема с подключением USB-COM переходников, по причине серьезной системе прав, но это можно исправить.

Сначала нужно узнать VendorID и ProductID нашего переходника. Это можно сделать такой командой:

~~~
lsusb | grep UART
~~~

Выдаст что то подобное 

~~~bash 
 Bus 003 Device 011: ID 0403:6001 Future Technology Devices International, Ltd FT232 USB-Serial (UART) IC
~~~

Запомните значения после аббревиатуры ID, они нам еще пригодятся. 

Теперь создаем файл в /etc/udev/rules.d/

~~~bash
sudo nano /etc/udev/rules.d/10-ft232.rules
~~~

В качестве называния удобно указать наименования чипа установленного в переходнике, в моем случае это ft232.

Теперь добавляем в открывшемся окне, такое содержимое (изменяем если нужно idVendor и idProduct, их мы записали в предыдущем пункте):

~~~bash
SUBSYSTEMS=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", \
    MODE:="0666", GROUP:="users",\
    SYMLINK+="ft232_%n"
~~~

Этой записью мы устанавливаем на USB устройство 0403:6001 права на запись и чтение обычным пользователям. А также говорим udev создавать символьную ссылку на него с именем ft232_номер.

Перезагружаем udev.

~~~bash
sudo udevadm control --reload-rules
~~~

Теперь проверяем права на наше устройство.

~~~bash
$ ls -l /dev/ | grep USB
lrwxrwxrwx. 1 root root             7 янв 25 15:09 ft232_0 -> ttyUSB0
crw-rw-rw-. 1 root users     188,   0 янв 25 15:09 ttyUSB0
~~~

Как видим нам удалось достичь желаемого результата. Теперь можно обращаться к этому порту без Root прав из любого удобного приложения.

Спасибо/ да, это конец ^ _ ^

